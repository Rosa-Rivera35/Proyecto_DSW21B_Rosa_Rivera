<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Simulaci√≥n ‚Äî Ley de Newton (F = m¬∑a) ‚Äî Carrito & Polea</title>
  <style>
    /* ======== ESTILO GENERAL ======== */
    :root{
      --bg1: #667eea;
      --bg2: #764ba2;
      --panel-bg: rgba(255,255,255,0.95);
    }
    html,body{height:100%;margin:0}
    body{
      background: linear-gradient(135deg,var(--bg1) 0%,var(--bg2) 100%);
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      color:#fff;
      display:flex;
      flex-direction:column;
      align-items:center;
      min-height:100vh;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    header{
      width:100%;
      background: rgba(255,255,255,0.08);
      backdrop-filter: blur(12px);
      display:flex;
      align-items:center;
      justify-content:center;
      padding:18px 20px;
      box-shadow:0 4px 20px rgba(0,0,0,0.18);
      border-bottom:1px solid rgba(255,255,255,0.12);
    }
    header img{height:44px;margin-right:14px}
    header h2{margin:0;font-size:1.5rem;text-shadow:0 2px 6px rgba(0,0,0,0.35)}

    /* SIMULADOR: contenedor grande arriba */
    .canvas-container {
      width:92%;
      max-width:1120px;
      margin-top:26px;
      background: var(--panel-bg);
      border-radius:16px;
      padding:14px;
      box-shadow:0 12px 30px rgba(0,0,0,0.18);
      backdrop-filter: blur(8px);
    }

    /* adapt canvas to container */
    #simulador {
      width:100%;
      height:420px; /* visual height; script sets actual resolution for crispness */
      display:block;
      border-radius:12px;
      background: linear-gradient(to top, #eef6ff 0%, #f8fbff 45%);
      box-shadow: inset 0 -8px 20px rgba(0,0,0,0.04);
    }

    /* panel inferior: bloques de colores (lab-like) */
    .panel{
      width:92%;
      max-width:1120px;
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap:14px;
      margin:24px 0 40px;
    }
    .bloque{
      padding:16px;
      border-radius:12px;
      box-shadow:0 6px 18px rgba(0,0,0,0.12);
      color:#fff;
    }
    .azul{background:#2b7cff}
    .morado{background:#8b5cf6}
    .verde{background:#2bb673}
    .naranja{background:#ff9a3c}
    label{display:block;font-weight:700;margin-top:10px;font-size:0.95rem}
    input,select{width:100%;padding:8px;border-radius:8px;border:none;margin-top:6px;font-size:0.95rem}
    button{
      width:100%;padding:10px;border-radius:8px;border:none;margin-top:10px;background:#fff;color:#222;font-weight:700;cursor:pointer;
    }
    button:hover{transform:translateY(-2px);background:#f2f2f2}

    footer{color:#fff;padding:10px 0 40px}

    @media (max-width:800px){
      #simulador{height:300px}
      header h2{font-size:1.15rem}
    }
  </style>
</head>
<body>

  <header>
     <a href="index.html">
      <img src="img/Itca.png" alt="Logo ITCA-FEPADE" style="cursor: pointer; border: none;">
    </a>
    <h1>Segunda Ley de Newton (F = m¬∑a)</h1>
  </header>

  <!-- SIMULADOR ARRIBA -->
  <div class="canvas-container">
    <canvas id="simulador"></canvas>
  </div>

  <!-- PANEL DE BLOQUES COLOREADOS ABAJO -->
  <div class="panel">
    <div class="bloque azul">
      <h3>‚öôÔ∏è Par√°metros F√≠sicos</h3>
      <label>Masa m‚ÇÅ (kg): <input type="number" id="m1" value="0.1" step="0.01"></label>
      <label>Masa m‚ÇÇ (kg): <input type="number" id="m2" value="0.1" step="0.01"></label>
      <label>Gravedad (m/s¬≤): <input type="number" id="g" value="9.8" step="0.1"></label>
      <label>Fricci√≥n:
        <select id="friccion">
          <option value="0">Sin fricci√≥n</option>
          <option value="0.2">Fricci√≥n</option>
          <option value="0.4">Resistencia a la rodadura</option>
        </select>
      </label>
    </div>

    <div class="bloque morado">
      <h3>üí™ Fuerza</h3>
      <label>Fuerza externa F (N): <input type="number" id="fuerzaExt" value="0" step="0.1"></label>
    </div>

    <div class="bloque verde">
      <h3>üìà Resultados</h3>
      <div id="resultados">
        <p>Fuerza: <span id="fuerza">‚Äì</span> N</p>
        <p>Aceleraci√≥n: <span id="aceleracion">‚Äì</span> m/s¬≤</p>
        <p>Velocidad: <span id="velocidad">‚Äì</span> m/s</p>
        <p>Distancia: <span id="distancia">‚Äì</span> m</p>
        <p>Tensi√≥n: <span id="tension">‚Äì</span> N</p>
        <p>‚è±Ô∏è <span id="cronometro">00.00 s</span></p>
      </div>
    </div>

    <div class="bloque naranja">
      <h3>üïπÔ∏è Controles</h3>
      <button onclick="iniciarCompleta()">‚ñ∂ Iniciar simulaci√≥n</button>
      <button onclick="avanzarPaso()">‚è© Avanzar</button>
      <button onclick="reiniciar()">üîÑ Reiniciar</button>
    </div>
  </div>

  <footer>¬© <span id="year"></span> Simulador ‚Äî Sindy Arias</footer>

<script>
/* ====== Inicializaci√≥n de canvas para pantallas retina ====== */
const canvas = document.getElementById('simulador');
const ctx = canvas.getContext('2d');

function resizeCanvas() {
  const ratio = Math.max(window.devicePixelRatio || 1, 1);
  const cssWidth = canvas.clientWidth || canvas.offsetWidth || 900;
  const cssHeight = parseInt(getComputedStyle(canvas).height, 10) || 420;
  canvas.width = Math.floor(cssWidth * ratio);
  canvas.height = Math.floor(cssHeight * ratio);
  ctx.setTransform(ratio,0,0,ratio,0,0);
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

/* ====== Elementos DOM y variables f√≠sicas (tu l√≥gica preservada) ====== */
document.getElementById('year').textContent = new Date().getFullYear();

const cronometro = document.getElementById('cronometro');
const fuerzaSpan = document.getElementById('fuerza');
const aceleracionSpan = document.getElementById('aceleracion');
const velocidadSpan = document.getElementById('velocidad');
const distanciaSpan = document.getElementById('distancia');
const tensionSpan = document.getElementById('tension');
const fuerzaExtInput = document.getElementById('fuerzaExt');
const friccionSelect = document.getElementById('friccion');

let m1 = parseFloat(document.getElementById('m1').value) || 0.1;
let m2 = parseFloat(document.getElementById('m2').value) || 0.1;
let g = parseFloat(document.getElementById('g').value) || 9.8;
let fr = parseFloat(friccionSelect.value) || 0;
let fuerzaExt = parseFloat(fuerzaExtInput.value) || 0;

let a = 0, Fnet = 0;
let posM1 = 0, posM2 = 0;      // posiciones normalizadas 0..1 (como antes)
let velocidad = 0, tiempo = 0;
let animando = false, lastTimestamp = null;
let tension = 0;

/* visual helpers */
let wheelAngle = 0;
let pulleyAngle = 0;

/* Conectar inputs a c√°lculos */
document.getElementById('m1').addEventListener('input', actualizarCalculos);
document.getElementById('m2').addEventListener('input', actualizarCalculos);
document.getElementById('g').addEventListener('input', actualizarCalculos);
friccionSelect.addEventListener('change', actualizarCalculos);
fuerzaExtInput.addEventListener('input', actualizarCalculos);

/* Funciones control (id√©nticas en funcionalidad) */
function iniciarCompleta(){ reiniciar(); animando=true; lastTimestamp=null; requestAnimationFrame(animar); }
function avanzarPaso(){
  if(!animando){
    actualizarCalculos();
    const paso = 0.01;
    if(Math.abs(a) > 1e-6){
      velocidad += a * 0.1;
      posM1 += Math.sign(a) * paso;
      posM2 += Math.sign(a) * paso;
      tiempo += 0.1;
    }
    actualizarDisplays();
    dibujarEscena();
  }
}
function reiniciar(){
  posM1 = posM2 = velocidad = tiempo = 0;
  animando = false; lastTimestamp = null;
  cronometro.textContent = "00.00 s";
  actualizarCalculos(); dibujarEscena();
}

/* C√°lculos f√≠sicos (id√©ntico al tuyo) */
function actualizarCalculos(){
  m1 = parseFloat(document.getElementById('m1').value) || 0;
  m2 = parseFloat(document.getElementById('m2').value) || 0;
  g = parseFloat(document.getElementById('g').value) || 9.8;
  fr = parseFloat(friccionSelect.value) || 0;
  fuerzaExt = parseFloat(fuerzaExtInput.value) || 0;

  const peso2 = m2 * g;
  const friccionMagnitud = fr * m1 * g;
  const friccion = friccionMagnitud * -Math.sign(fuerzaExt + peso2);
  Fnet = peso2 + fuerzaExt + friccion;
  a = (m1 + m2) > 0 ? Fnet / (m1 + m2) : 0;
  tension = m2 * g - m2 * a;

  fuerzaSpan.textContent = Fnet.toFixed(2);
  aceleracionSpan.textContent = a.toFixed(2);
  tensionSpan.textContent = tension.toFixed(2);
}

function actualizarDisplays(){
  velocidadSpan.textContent = velocidad.toFixed(2);
  distanciaSpan.textContent = posM1.toFixed(2);
  cronometro.textContent = tiempo.toFixed(2) + " s";
}

/* Animaci√≥n principal (se conserva la l√≥gica pero a√±adimos rotaci√≥n visual) */
function animar(timestamp){
  if(!animando) return;
  if(!lastTimestamp) lastTimestamp = timestamp;
  const dt = Math.min(0.05, (timestamp - lastTimestamp)/1000);
  lastTimestamp = timestamp;

  actualizarCalculos();
  velocidad += a * dt;
  posM1 += velocidad * dt;
  posM2 += velocidad * dt;
  tiempo += dt;

  // limitar posiciones normalizadas entre 0 y 1
  if(posM1 < 0) posM1 = 0;
  if(posM1 > 1.0){ posM1 = 1.0; velocidad = 0; animando=false; }
  if(posM2 < 0) posM2 = 0;
  if(posM2 > 1.0){ posM2 = 1.0; velocidad = 0; animando=false; }

  // Actualizar rotaciones visuales en funci√≥n de la velocidad
  // ruedaRadio en px para c√°lculo aproximado de giro visual
  const wheelRadius = 12;
  wheelAngle += (velocidad * dt) * (1 / (2 * Math.PI * wheelRadius)) * 2 * Math.PI * 40; // factor ajustado para ver rotaci√≥n
  pulleyAngle += (velocidad * dt) * 0.8; // rotaci√≥n de polea m√°s lenta

  actualizarDisplays();
  dibujarEscena();

  if(animando) requestAnimationFrame(animar);
  else cronometro.textContent = "Finalizado";
}

/* =========================
   DIBUJAR ESCENA (mejorada)
   ========================= */
function dibujarEscena(){
  // retina-safe: canvas.width/height ya ajustados en resizeCanvas
  const W = canvas.clientWidth;
  const H = parseInt(getComputedStyle(canvas).height,10);

  // clear
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // draw background subtle grid / lab floor
  // (use device-independent coordinates because ctx scaled already)
  ctx.save();
  // soft gradient background (inside panel)
  const g = ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0,'#f6fbff');
  g.addColorStop(0.5,'#eef6ff');
  g.addColorStop(1,'#f4fbff');
  ctx.fillStyle = g;
  ctx.fillRect(0,0,W,H);

  // ground plane (track)
  const trackX = 60;
  const trackY = Math.round(H * 0.65);
  const trackWidth = Math.round(W - 120);
  ctx.fillStyle = '#d7eef3';
  ctx.fillRect(trackX, trackY - 6, trackWidth, 12);

  // track base shading
  ctx.fillStyle = 'rgba(0,0,0,0.06)';
  ctx.fillRect(trackX, trackY + 6, trackWidth, 8);

  // draw meter ticks on track
  ctx.strokeStyle = 'rgba(0,0,0,0.12)';
  ctx.lineWidth = 1;
  for(let i=0;i<=10;i++){
    const x = trackX + (i*(trackWidth/10));
    ctx.beginPath();
    ctx.moveTo(x, trackY-10);
    ctx.lineTo(x, trackY+10);
    ctx.stroke();
  }

  // coordinates mapping for normalized positions:
  const cartMin = trackX + 20; // leftmost cart x
  const cartMax = trackX + trackWidth - 140; // rightmost cart x (keeps spacing to pulley)
  const cartX = cartMin + posM1 * (cartMax - cartMin);

  // polea position
  const pulleyX = trackX + trackWidth - 60;
  const pulleyY = trackY - 120;

  // draw support beam to pulley
  ctx.strokeStyle = '#8b9099';
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.moveTo(pulleyX, pulleyY - 50);
  ctx.lineTo(pulleyX, pulleyY + 8);
  ctx.stroke();

  // draw pulley (metallic)
  const pulleyR = 22;
  // pulley shadow
  ctx.beginPath();
  ctx.arc(pulleyX + 6, pulleyY + 8, pulleyR + 6, 0, Math.PI*2);
  ctx.fillStyle = 'rgba(0,0,0,0.06)';
  ctx.fill();

  // pulley body (metal)
  const pg = ctx.createLinearGradient(pulleyX - pulleyR, pulleyY - pulleyR, pulleyX + pulleyR, pulleyY + pulleyR);
  pg.addColorStop(0, '#d7dbe0');
  pg.addColorStop(0.5, '#bfc4c9');
  pg.addColorStop(1, '#dfe3e8');
  ctx.beginPath();
  ctx.arc(pulleyX, pulleyY, pulleyR, 0, Math.PI*2);
  ctx.fillStyle = pg;
  ctx.fill();
  ctx.lineWidth = 2;
  ctx.strokeStyle = '#8b8f95';
  ctx.stroke();

  // pulley inner hub
  ctx.beginPath();
  ctx.arc(pulleyX, pulleyY, 6, 0, Math.PI*2);
  ctx.fillStyle = '#666';
  ctx.fill();

  // draw rope: from cart attach point -> pulley rim -> down to mass2
  // cart attach point (right edge of cart top)
  const attachX = cartX + 110; // adjust to cart width used below
  const attachY = trackY - 40;

  // compute mass2 position (vertical)
  const mass2MinY = pulleyY + 24;
  const mass2MaxY = pulleyY + 24 + 220; // maximum drop
  const mass2Y = mass2MinY + posM2 * (mass2MaxY - mass2MinY);

  // rope path
  ctx.strokeStyle = '#3b3b3b';
  ctx.lineWidth = 2.2;
  ctx.beginPath();
  ctx.moveTo(attachX, attachY);
  // little sag to pulley entry point
  const midX = pulleyX - 10;
  const midY = pulleyY - 10;
  ctx.quadraticCurveTo((attachX + midX)/2, attachY - 10, midX, midY);
  // over pulley rim to down
  // point on rim slightly offset to simulate wrap
  const rimX = pulleyX + Math.cos(pulleyAngle) * pulleyR * 0.85;
  const rimY = pulleyY + Math.sin(pulleyAngle) * pulleyR * 0.85;
  ctx.lineTo(rimX, rimY);
  ctx.lineTo(pulleyX, mass2Y);
  ctx.stroke();

  // draw cart (m1) as a stylized car / trolley
  const cartW = 120;
  const cartH = 36;
  const cartY = trackY - cartH - 14; // vertical position of cart body
  // shadow under cart
  ctx.beginPath();
  ctx.ellipse(cartX + cartW/2, trackY + 2, cartW*0.55, 12, 0, 0, Math.PI*2);
  ctx.fillStyle = 'rgba(0,0,0,0.12)';
  ctx.fill();

  // cart body
  ctx.fillStyle = '#2196f3';
  roundRect(ctx, cartX, cartY, cartW, cartH, 8, true, false);

  // cart cabin
  ctx.fillStyle = '#1e88e5';
  roundRect(ctx, cartX + 62, cartY - 18, 44, 18, 6, true, false);

  // cart trim highlight
  ctx.strokeStyle = 'rgba(255,255,255,0.12)';
  ctx.lineWidth = 1;
  ctx.strokeRect(cartX + 8, cartY + 4, cartW - 16, cartH - 8);

  // draw wheels with rotation
  const wheelRadius = 12;
  const wheel1X = cartX + 24;
  const wheel2X = cartX + cartW - 24;
  const wheelY = cartY + cartH + 8;

  drawWheel(wheel1X, wheelY, wheelRadius, wheelAngle);
  drawWheel(wheel2X, wheelY, wheelRadius, wheelAngle);

  // label m1 and show its mass above the cart
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 14px Segoe UI';
  ctx.fillText('m‚ÇÅ = ' + (m1 || 0).toFixed(2) + ' kg', cartX + 8, cartY - 8);
  ctx.font = '12px Segoe UI';
  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  // small arrow/attachment point
  ctx.beginPath();
  ctx.arc(attachX - 4, attachY - 2, 3, 0, Math.PI*2);
  ctx.fillStyle = '#555';
  ctx.fill();

  // draw mass 2 (hanging box)
  const mass2W = 40;
  const mass2H = 32;
  const mass2X = pulleyX - mass2W/2;
  ctx.fillStyle = '#e53935';
  roundRect(ctx, mass2X, mass2Y, mass2W, mass2H, 6, true, false);
  // shadow
  ctx.fillStyle = 'rgba(0,0,0,0.08)';
  ctx.fillRect(mass2X + 4, mass2Y + mass2H + 2, mass2W - 8, 6);

  // label m2
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 13px Segoe UI';
  ctx.fillText('m‚ÇÇ = ' + (m2 || 0).toFixed(2) + ' kg', mass2X - 2, mass2Y + mass2H + 22);

  // tension visual (a small line on the rope near mass)
  const tensionVis = Math.min(80, Math.abs(tension) * 4);
  ctx.strokeStyle = 'rgba(0,180,0,0.9)';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(pulleyX, mass2Y + mass2H/2);
  ctx.lineTo(pulleyX, mass2Y + mass2H/2 - tensionVis);
  ctx.stroke();
  ctx.font = '12px Segoe UI';
  ctx.fillStyle = '#000';
  ctx.fillText('T=' + tension.toFixed(2) + ' N', pulleyX + 12, mass2Y + mass2H/2 - tensionVis/2);

  ctx.restore();
}

/* Helper: rounded rectangle */
function roundRect(ctx, x, y, w, h, r, fill, stroke){
  if (typeof r === 'undefined') r = 5;
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, x, y, r);
  ctx.arcTo(x, y, x + w, y, r);
  ctx.closePath();
  if(fill) ctx.fill();
  if(stroke) ctx.stroke();
}

/* Helper: draw wheel with spokes */
function drawWheel(cx, cy, r, angle){
  ctx.save();
  ctx.translate(cx, cy);
  ctx.rotate(angle);
  // tire
  ctx.beginPath();
  ctx.arc(0,0,r,0,Math.PI*2);
  ctx.fillStyle = '#222';
  ctx.fill();

  // rim
  ctx.beginPath();
  ctx.arc(0,0,r*0.6,0,Math.PI*2);
  ctx.fillStyle = '#666';
  ctx.fill();

  // spokes
  ctx.strokeStyle = '#444';
  ctx.lineWidth = 2;
  for(let i=0;i<6;i++){
    ctx.beginPath();
    ctx.moveTo(0,0);
    const ax = Math.cos((i/6) * Math.PI*2) * (r*0.6);
    const ay = Math.sin((i/6) * Math.PI*2) * (r*0.6);
    ctx.lineTo(ax, ay);
    ctx.stroke();
  }
  ctx.restore();
}

/* ========== inicial draw ========== */
actualizarCalculos();
dibujarEscena();

/* Exponer dibujarEscena al resto del script (ya usado por animar/avanzar etc.) */
window.dibujarEscena = dibujarEscena;

/* si el script f√≠sico original recalcula y llama dibujarEscena(), todo seguir√° funcionando */
</script>

<!-- Mantengo tu script f√≠sico original en el mismo archivo para que controles y c√°lculos
     sigan funcionando exactamente como antes. He adaptado nombres para evitar conflictos. -->
<script>
/* ======= L√≥gica f√≠sica (copia de la tuya, adaptada para integrarse con la vista)
   Observa: no he cambiado f√≥rmulas; solo reorganic√© para usar la misma funci√≥n dibujarEscena() */
(function(){
  // variables ya definidas en el bloque anterior: m1,m2,g,fr,fuerzaExt,a,Fnet,tension,posM1,posM2,velocidad,tiempo,animando,lastTimestamp
  const m1input = document.getElementById('m1');
  const m2input = document.getElementById('m2');
  const ginput  = document.getElementById('g');
  const frinput = document.getElementById('friccion');
  const fExtInput = document.getElementById('fuerzaExt');

  // enlazamos eventos (si no estaban enlazados)
  m1input.addEventListener('input', actualizarCalculos);
  m2input.addEventListener('input', actualizarCalculos);
  ginput.addEventListener('input', actualizarCalculos);
  frinput.addEventListener('change', actualizarCalculos);
  fExtInput.addEventListener('input', actualizarCalculos);

  // re-definimos animar para usar lo que ya definimos anteriormente (esto actualiza rotaciones)
  function animarOriginal(timestamp){
    if(!animando) return;
    if(!lastTimestamp) lastTimestamp = timestamp;
    const dt = Math.min(0.05,(timestamp - lastTimestamp)/1000);
    lastTimestamp = timestamp;

    actualizarCalculos();

    velocidad += a * dt;
    posM1 += velocidad * dt;
    posM2 += velocidad * dt;
    tiempo += dt;

    if(posM1 < 0) posM1 = 0;
    if(posM1 > 1.0){ posM1 = 1.0; velocidad = 0; animando=false; }
    if(posM2 < 0) posM2 = 0;
    if(posM2 > 1.0){ posM2 = 1.0; velocidad = 0; animando=false; }

    // visual rotations
    wheelAngle += (velocidad * dt) * 0.6;
    pulleyAngle += (velocidad * dt) * 0.35;

    actualizarDisplays();
    dibujarEscena();

    if(animando) requestAnimationFrame(animarOriginal);
    else cronometro.textContent = "Finalizado";
  }

  // sustituimos la funci√≥n p√∫blica "iniciarCompleta" para usar este animarOriginal
  window.iniciarCompleta = function(){ reiniciar(); animando = true; lastTimestamp = null; requestAnimationFrame(animarOriginal); }

  // avanzar paso (usa tu misma l√≥gica)
  window.avanzarPaso = function(){
    if(!animando){
      actualizarCalculos();
      const paso = 0.01;
      if(Math.abs(a) > 1e-6){
        velocidad += a * 0.1;
        posM1 += Math.sign(a) * paso;
        posM2 += Math.sign(a) * paso;
        tiempo += 0.1;
      }
      actualizarDisplays();
      dibujarEscena();
    }
  }

  window.reiniciar = function(){
    posM1 = posM2 = velocidad = tiempo = 0;
    animando = false; lastTimestamp = null;
    cronometro.textContent = "00.00 s";
    actualizarCalculos(); dibujarEscena();
  }

  // inicializamos calcs y dibujo
  actualizarCalculos();
  dibujarEscena();
})();
</script>

</body>
</html>
